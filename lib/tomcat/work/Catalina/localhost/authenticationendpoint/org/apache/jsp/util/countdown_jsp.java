/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/9.0.98
 * Generated at: 2025-07-07 07:26:08 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp.util;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class countdown_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.LinkedHashSet<>(4);
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      final java.lang.String _jspx_method = request.getMethod();
      if ("OPTIONS".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        return;
      }
      if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET, POST or HEAD. Jasper also permits OPTIONS");
        return;
      }
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("\n");
      out.write("<script>\n");
      out.write("\n");
      out.write("    const ZERO = 0;\n");
      out.write("    const THOUSAND_MILLISECONDS = 1000;\n");
      out.write("    const ONE_MINUTE = 60; // 1 * 60 Seconds\n");
      out.write("    const ONE_HOUR = 60; // 1 * 60 minutes\n");
      out.write("    const ONE_DAY = 24; // Hours\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * This function will give you a new instance of a Countdown object.\n");
      out.write("     * You can create the instance like for example:-\n");
      out.write("     *\n");
      out.write("     *      const countdown1 = new Countdown(Countdown.seconds(5), function () {\n");
      out.write("     *          // On done\n");
      out.write("     *      }, function (time) {\n");
      out.write("     *          // On tick\n");
      out.write("     *      }, \"MY_TIMER\").start();\n");
      out.write("     *\n");
      out.write("     *      const countdown2 = new Countdown(Countdown.seconds(5), function () {\n");
      out.write("     *          // On done\n");
      out.write("     *      }, null, \"MY_TIMER\").start();\n");
      out.write("     *\n");
      out.write("     *      const countdown3 = new Countdown(Countdown.seconds(5), function () {\n");
      out.write("     *          // On done\n");
      out.write("     *      }).start();\n");
      out.write("     *\n");
      out.write("     *\n");
      out.write("     * How can you utilize the onTick callback to do stuff?\n");
      out.write("     *\n");
      out.write("     * If you want to trigger some action on a specific time, what you can do is\n");
      out.write("     * check each time component state or in relative time. For example:-\n");
      out.write("     *\n");
      out.write("     * #1 Time state condition check\n");
      out.write("     * -----------------------------\n");
      out.write("     * Now say for example you set a countdown of 5 minutes\n");
      out.write("     * and want to run some code after 2 minute and 15 seconds\n");
      out.write("     * of the countdown. You can have a condition like:-\n");
      out.write("     *\n");
      out.write("     *      if (time.minutes === 2 && time.seconds === 45)\n");
      out.write("     *          # will execute once.\n");
      out.write("     *      if (time.minutes <= 2 && time.seconds <= 45)\n");
      out.write("     *          # will execute until finished.\n");
      out.write("     *\n");
      out.write("     * #2 Total time state relative check\n");
      out.write("     * ----------------------------------\n");
      out.write("     * Following the same example you can place a condition like below:-\n");
      out.write("     *\n");
      out.write("     *      const checkpoint = Countdown.minutes(2) + Countdown.seconds(15);\n");
      out.write("     *\n");
      out.write("     *      if (time.total === checkpoint)\n");
      out.write("     *          # will execute once\n");
      out.write("     *      if (time.total < checkpoint)\n");
      out.write("     *          # will execute until finished\n");
      out.write("     *\n");
      out.write("     * @param time {number} as minutes/seconds/hours.\n");
      out.write("     * @param onDone {function} called when countdown ends.\n");
      out.write("     * @param onTick {function({total: number, hours: number, seconds: number, minutes: number, days: number})}\n");
      out.write("     * @param name {String} a descriptive name for the timer.\n");
      out.write("     */\n");
      out.write("    function Countdown(\n");
      out.write("        time = ZERO,\n");
      out.write("        onDone = Countdown.noop,\n");
      out.write("        onTick = Countdown.noop,\n");
      out.write("        name = \"COUNTDOWN\"\n");
      out.write("    ) {\n");
      out.write("        this.until = new Date(Date.now() + time);\n");
      out.write("        this.onTick = onTick;\n");
      out.write("        this.onDone = onDone;\n");
      out.write("        this.name = name;\n");
      out.write("        this._enableLogs = false;\n");
      out.write("        this._timerInterval = null;\n");
      out.write("        this._running = false;\n");
      out.write("    }\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * Starts the countdown. If it's running calling this\n");
      out.write("     * multiple times won't reset the countdown.\n");
      out.write("     */\n");
      out.write("    Countdown.prototype.start = function () {\n");
      out.write("        if (!this._running) {\n");
      out.write("            // Since we have to use setInterval here we need to make\n");
      out.write("            // sure the scope of 'this' is bind to callee.\n");
      out.write("            this._timerInterval = setInterval(function () {\n");
      out.write("                this.tick();\n");
      out.write("            }.bind(this), THOUSAND_MILLISECONDS);\n");
      out.write("            this._running = true;\n");
      out.write("            this.log(\"Countdown: \" + this.name + \" started.\");\n");
      out.write("        }\n");
      out.write("        return this;\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * Stops the countdown. When not running calling this\n");
      out.write("     * will have no affect to the countdown instance.\n");
      out.write("     */\n");
      out.write("    Countdown.prototype.stop = function () {\n");
      out.write("        if (this._running) {\n");
      out.write("            clearInterval(this._timerInterval);\n");
      out.write("            this._running = false;\n");
      out.write("            if (this.onDone) {\n");
      out.write("                this.onDone();\n");
      out.write("            }\n");
      out.write("            this.log(\"Countdown \" + this.name + \" stopped.\");\n");
      out.write("        }\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.prototype.log = function (message) {\n");
      out.write("        if (this._enableLogs && console && console.debug && message) {\n");
      out.write("            console.debug(message);\n");
      out.write("        }\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * Returns the remaining time as days, hours, minutes, and\n");
      out.write("     * seconds. It also include a total sum of epoch seconds\n");
      out.write("     * left (multiplied by 1000).\n");
      out.write("     */\n");
      out.write("    Countdown.prototype.getRemainingTime = function () {\n");
      out.write("        const total = Date.parse(this.until.toString()) - Date.parse(new Date().toString());\n");
      out.write("        const seconds = Math.floor((total / THOUSAND_MILLISECONDS) % ONE_MINUTE);\n");
      out.write("        const minutes = Math.floor((total / THOUSAND_MILLISECONDS / ONE_MINUTE) % ONE_MINUTE);\n");
      out.write("        const hours = Math.floor((total / (THOUSAND_MILLISECONDS * ONE_MINUTE * ONE_MINUTE)) % ONE_DAY);\n");
      out.write("        const days = Math.floor(total / (THOUSAND_MILLISECONDS * ONE_MINUTE * ONE_MINUTE * ONE_DAY));\n");
      out.write("        return { total, days, hours, minutes, seconds };\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * Calls every second when the timer is started.\n");
      out.write("     */\n");
      out.write("    Countdown.prototype.tick = function () {\n");
      out.write("        const time = this.getRemainingTime();\n");
      out.write("        if (this.onTick) {\n");
      out.write("            this.onTick(time);\n");
      out.write("        }\n");
      out.write("        if (time.total <= ZERO) {\n");
      out.write("            this.stop();\n");
      out.write("        }\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.seconds = function (input) {\n");
      out.write("        return (input * ONE_MINUTE * THOUSAND_MILLISECONDS) / ONE_MINUTE;\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.minutes = function (input) {\n");
      out.write("        return input * ONE_MINUTE * THOUSAND_MILLISECONDS;\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.hours = function (input) {\n");
      out.write("        return input * ONE_MINUTE * THOUSAND_MILLISECONDS * ONE_HOUR;\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.days = function (input) {\n");
      out.write("        return (input * ONE_MINUTE * THOUSAND_MILLISECONDS) * ONE_HOUR * ONE_DAY;\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    /**\n");
      out.write("     * @param time {{\n");
      out.write("     *          total: number,\n");
      out.write("     *          hours: number,\n");
      out.write("     *          seconds: number,\n");
      out.write("     *          minutes: number,\n");
      out.write("     *          days: number\n");
      out.write("     *       }}\n");
      out.write("     */\n");
      out.write("    Countdown.timeToReadable = function (time) {\n");
      out.write("\n");
      out.write("        let str = \"\"; // 1 days(s), 1 hour(s), 1 minute(s) and 30 second(s)\n");
      out.write("        let hasPrevious = false;\n");
      out.write("\n");
      out.write("        if (time.days > 0) {\n");
      out.write("            if (time.days === 1) {\n");
      out.write("                str += \"1 day\";\n");
      out.write("            } else {\n");
      out.write("                str += String(time.days) + \" days\";\n");
      out.write("            }\n");
      out.write("            hasPrevious = true;\n");
      out.write("        }\n");
      out.write("\n");
      out.write("        if (time.hours > 0) {\n");
      out.write("            if (hasPrevious) str += \", \";\n");
      out.write("            if (time.hours === 1) {\n");
      out.write("                str += \"1 hour\";\n");
      out.write("            } else {\n");
      out.write("                str += String(time.hours) + \" hours\";\n");
      out.write("            }\n");
      out.write("            hasPrevious = true;\n");
      out.write("        }\n");
      out.write("\n");
      out.write("        if (time.minutes > 0) {\n");
      out.write("            if (hasPrevious) str += \", \";\n");
      out.write("            if (time.minutes === 1) {\n");
      out.write("                str += \"1 minute\";\n");
      out.write("            } else {\n");
      out.write("                str += String(time.minutes) + \" minutes\";\n");
      out.write("            }\n");
      out.write("            hasPrevious = true;\n");
      out.write("        }\n");
      out.write("\n");
      out.write("        if (time.seconds > 0) {\n");
      out.write("            if (hasPrevious) str += \", and \";\n");
      out.write("            if (time.seconds === 1) {\n");
      out.write("                str += \"1 second\";\n");
      out.write("            } else {\n");
      out.write("                str += String(time.seconds) + \" seconds\";\n");
      out.write("            }\n");
      out.write("        }\n");
      out.write("\n");
      out.write("        if (!str) return \"now\";\n");
      out.write("        return \"in \" + str;\n");
      out.write("\n");
      out.write("    };\n");
      out.write("\n");
      out.write("    Countdown.noop = function () {\n");
      out.write("        // No operations\n");
      out.write("    };\n");
      out.write("\n");
      out.write("</script>\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
